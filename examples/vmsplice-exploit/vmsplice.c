#include <xentt.h>

/*
   Analysis invocation
   -------------------  
 
   The general idea for connecting multiple analyses is to use a funciton which runs 
   a specified analysis on a replay session: 
   
      xentt_run_replay(<analysis>, <replay session>);

   It's a rather simple function which basically registers analysis probes with VMI, 
   forks a replay process, and then runs VMI on this process. 
   
   All analyses arguments and return values are passed via a data structure, which is 
   private to each analysis. Below we name this data structure as <analysis name>_in_out. 
   
   This approach allows us to pass analysis requests and results in  XML. 
  
   Results caching
   ---------------

   We anticipate that a person, who develops the analysis script (the program below, 
   which is written in C, but is essentially a script) will go through a number of 
   iterations aimed at exploring the actual cause of the problem. To avoid running 
   replay sessions over and over for already computed values (e.g. the branch counter 
   at which /etc/passwd was accessed) we implement a transparent chaching infrastrucure. 

   We save analysis request specified in the *_in_out structure in XML, use it as a hash 
   value, and keep the computed analysis result iin the cash. This analysis result is also 
   serialized (I guess XML again).

   So the xentt_run_replay function first checks if analysis request is in the
   cache, if yes it skips replay, and just de-serializes XML value from the cache;
   if not, then replay is launched. 

   A minor technical note: analysis is identified by its name (e.g. 
   file_access_analysis->name), analysis request is identified by the content of the 
   private data (e.g. file_access_analysis->priv, which is serialized by the serialization 
   function file_access_analysis->serialize()). 

   Analysis pairing
   ----------------

   In a number of cases below we run into the following situation -- we want to pair two 
   analyses and run them simultaneously. For example, we want to collect a BTS trace of all 
   branches taken by a process, and join it with the trace of all accesses to some variable. 
   This way we know where in the trace/code this variable is accessed. 

   Another pairing example is use process lifetime analysis to track process creation, and then 
   pair it with the the variable access analysis to track all accesses to the process UID field. 
   In this example pairing is a way to define "scope" for the second analysis.  

   To implement this pairing (I'm not arguing this is an ideal approach) we register the 
   second analysis from the event handler of the first analysis. But maybe Dave has a better 
   idea.

   General analyses 
   ---------------- 

   We use the wollowing genereal purpose analyses to implement this specific 
   example: 
  
     - File access analysis 
         input: list of file names, and access type to track
         output: list of access lists for each specified file, each access record 
                 includes (pid of the accessing process, and brctr)

     - Variable access analysis 
         input: list of variables to track, scope (global, function name)
         output: list of access lists for each specified variable

     - Process lifetime analysis
         input: process id, start branch counter
         output: list of process related events (e.g. created, deleted)
 
     - BTS trace analysis
         input: start branch counter, end branch counter, scope (global, or process id)
         output: trace of all taken branches (generated with BTS facility)

     - Single-step analysis 
         input: start branch counter, end branch counter, scope (global, or process id)
         output: instruction level trace of execution

   Helping functions
   ----------------- 
   
   Each analysis is surrounded with a family of functions, which help to interpret 
   analysis results. The most interesting examples are functions which annotate 
   BTS and single-step traces. The examples of how I think annotation should look are 
   below in the code. 
 
 */
 

int main(void) {
   
    /* 
     * Inital pass: check if one of the processes tries to write /etc/passwd 
     * 
     * We use a general file access analysis with the "/etc/passwd", and 
     * write access arguments.

     * Retval: list of all {brstr, pid, name, ppid, pname}.
     * 
     * Note: I guess it makes sense for the analysis runs to return lists of 
     *       values, since in case of multiple file accesses we would have this
     *       information anyway, so why throw it away. 
     */
    file_access_analysis_in_out->file_list = {{"/etc/passwd", W_ONLY}};

    file_access_analysis->priv = (void *) file_access_analysis_in_out;
    ret = xentt_run_replay(file_access_analysis, replay_session);
    if (ret) {
        ERR("Failed to run /etc/passwd analysis, ret:%d\n", ret); 
        return ret;
    }

    file_access = list_head(xentt_file_access_analysis_get_list(
                                  file_access_analysis_in_out, "/etc/passwd"));

    printf("/etc/passwd was written at brctr:%llu, by pid:%lu (%s)\n", 
           file_access->brctr, 
           file_access->pid,
           file_access->name);

    /* If process starts as root, we repeat the analysis for its parent */
    if( !xentt_proc_is_uid_root(file_access->uid)) {
        ERR("A non-root process tries to write /etc/passwd, we don't know what to do\n");
        return -1;
    }       
 

    /*
     * Second pass: walk up the parent process tree trying to find a process
     * for which the UID attribute changes 
     * 
     * We use a general analysis "process_lifetime", which is designed to track
     * process lifetime -- creation, delition. To identify accesses to the UID
     * field, the process lifetime analysis is paired with another general
     * analysis -- "variable access" analysis. Here, by pairing I mean that
     * when the process is created, we start the "access to variables" analysis
     * to start tracking write accesses to the process uid field. If the
     * process is created with root UID, we don't need to track anything, in
     * this case we just exit analysis, and kill the replay run right away. 
     * 
     * XXX: how to make this pairing? This is an opportunity for dataflow, e.g.
     * the proc_lifetime analysis emits a "proc_created" event, we register to
     * listen on this event, and register the variable access tracker from the
     * "proc_created" handler. But this is not entirely clear to me, so someone
     * (Dave) tell me your ideas. 
     * 
     * XXX: for now I do a parining through a on_create() function, which
     * registers the variable access analysis on a uid variable
     */

    proc_lifetime_in_out->pid = file_access->pid;

    /* XXX: Oh nice, while(1) loop....*/ 

    do { 

        struct uid_change uid_change; 

        if(proc_access_in_out->pid == xentt_proc_init_pid()) {
            ERR("We've reached the init process in the chain, chain is broken, fail\n");
            return -1;
        }

        var_access_analysis_in_out->var_list = {{"uid", W_ONLY}};
        var_access_analysis_in_out->var_list_size = 1;
        var_access_analysis_in_out->scope = {"global"};

	proc_lifetime_in_out->events->on_create = on_create;
        proc_lifetime_analysis->private = (void *) proc_lifetime_in_out;

        ret = xentt_run_replay(proc_lifetime_analysis, replay_session);
        if (ret) {
            ERR("Failed to run /etc/passwd analysis, ret:%d\n", ret); 
            return ret;
        }

        /* If process starts as root, we repeat the analysis for its parent */
        uid_access_list = xentt_var_access_get_list(var_access_analysis_in_out, "uid"); 

        if( xentt_proc_is_uid_root(xentt_val_to_ulong(list_head(uid_access_list)->value))) {
            proc_lifetime_in_out->pid = proc_lifetime_in_out->ppid;
            continue; 
          
        }       

        /* var_access_analysis returns a list of all places at which a particular 
           variable was accessed on write, the first element of the list is the value at 
           registration (uid of the process on start). */

        uid_change_on_start = list_head(uid_access_list); 
        uid_change = list_next(uid_change_on_start); 

        if(!uid_change == NULL) {
             ERR("Process wasn't created as root but we failed to find a UID change\n");
             return -1;
        };

        if(!xentt_proc_is_uid_root(xentt_val_to_ulong(uid_change->value))) {
             ERR("Process changes its UID, but not to root, we "
                 "can parse the change list further, but fail for now\n");
             return -1;
        };

        break;     
       
    } while (1);


    /* Check if UID is changed from the user code, otherwise the 
       analysis gets stuck */

    if (!xentt_os_user_address(uid_change->eip)) {
        ERR("UID is changed from the kernel address, we don't know what to do, fail\n");
        return -1;
    }

    printf("Process pid:%lu (name:%s) changes escalates its privilege to root\n", 
           proc_lifetime_in_out->pid, proc_lifetime_in_out->name);

    /* 
       Next pass: we now know which process gets its UID changed, and we also 
       know that UID is changed from the user-level code, so now we want to 
       see how does kernel ends up executing this code.

       An ideal course of action here is to collect an execution trace for the 
       suspect process.
  
       From the process lifetime analysis, we know at which brcrt the suspect 
       process is created, we instruct trace analysis to start from that brcrt.

       Note: process trace uses hardware branch tracing store (BTS), and context
       tracking analysis to collect a trace of an individual process. When the 
       process is context switched in, the analysis turn the BTS on, when it's context 
       switched out, the BTS is turned off. Note that some interrupt processing 
       might happen on behalf of the process. We don't filter this processing from 
       the trace, but mark it as interrupt related.  
     */

    bts_trace_analysis_in_out->scope = SCOPE_PROCCESS;
    bts_trace_analysis_in_out->pid = proc_lifetime_in_out->pid; 
    bts_trace_analysis_in_out->start_brctr = proc_lifetime_in_out->created_brcrt;

    ret = xentt_run_replay(bts_trace_analysis_in_out, replay_session);
    if (ret) {
        ERR("Failed to run process trace analysis, ret:%d\n", ret); 
        return ret;
    }

    /*
     * Next step: analysis of the trace
     * 
     * Since we've collected the execution trace of the suspect process, 
     * we want to extract some infromation out of it: 
     * 
     * An arguably bogus (too narrow) xentt_bts_trace_search_for_noniret_k2u_transition 
     * functions searches a trace for the kernel to user transition which is performed through 
     * a non well-known iret point. 
     * 
     * In a way this function is a version of CFI, which looks for a specific 
     * violation. And hey, it does CFI over a trace. 
     */     

    ret = xentt_bts_trace_search_for_noniret_k2u_transition(bts_trace_analysis_in_out->trace, 
                                                            &transition);     
    if (ret) {
        ERR("Failed to find kernel to user transition in the process trace, ret:%d\n", ret); 
        return ret;
    }   

    /* We want to take a look at how the execution jumps into the user 
       space. In case of vmsplice we want user to see the following output: 

          static void put_compound_page(struct page *page)
          {
              page = (struct page *)page_private(page);
              if (put_page_testzero(page)) {
                  void (*dtor)(struct page *page);

                  dtor = (void (*)(struct page *))page[1].lru.next;
                  (*dtor)(page);
              }
          } 

     */
    xentt_resolve_source(target, transition->eip_from);

    /* 
     * Next step: analysis of the page destructor
     *
     * At this point a human must conclude from the source code above that
     * the execution flow jumps to the user-level code because somehow 
     * page[1].lru.next got abused. 
     * 
     * Two questions need to be answered: 
     *    1) when this page structure was created (allocation scope)
     *    2) when the page[1].lru.next pointer was overwritten
     */

    /* Next step: power call stack (Q1: when the page pointer is created) 
	
     * To answer the first question we ask analysis to print out the function
     * call stack at the moment when page[1].lru.next is called from inside the
     * put_compound_page function. In reality, we want a little bit more than a
     * function call stack -- we want to know how did execution ends up
     * executing a rogue destructor, so we really want an annotated part of the
     * execution trace, but of course, with the call stack clearly visible too. 

     * We need the call stack because in the example of vmsplice exploit it
     * provides  the answer to the guestion of where the page struct was
     * allocated -- in this specific case allocation is on the stack, and human
     * can find it quickly. In a way it's a human-driven data-flow analysis,
     * and I don't see a way how we can make it better. 
       
     * There are multiple ways to collect a power call stack, but since we
     * already have the execution trace, we'll extract it from there.

     * Of course an obvious alternative is to collect the function call trace
     * and stack with the CFI analysis. We can do that in the interests of
     * time. 
     * 
     * There is a couple of arguments against the CFI approach. Later, I use an
     * intersection of BTS trace and variable access analyses to highlight at
     * which points of execution inside loop functions variables get
     * incremented. It will be harder to do with CFI. Another thing is that CFI
     * is not complete, but maybe this is already solved by Dave. 
     */ 

    /* To make our job easier, lets start collecting the power call stack from the 
       last system call -- last point at which execution enters the kernel.
  
     * We  do that in two steps: 1) extract all preiods of execution when the
     * process executes in the kernel space; 2) find for an kernel entry-exit
     * pair which surrounds the branch counter at which the kernel to user
     * jump happens.         
     */

    xentt_bts_trace_find_when_in_kernel(bts_trace_analysis_in_out->trace,
                                            &in_kernel_list);

    /* Now we search for the "in kernel" part of execution during which the 
        page destructor is called */

    while((in_kernel = list_head(in_kernel_list)) != NULL) {
        if (in_kernel->entry_brctr <= k2u_jump_brctr && 
            k2u_jump_brctr <= in_kernel->exit_brctr) {
            break;
        }  
    }

    vmsplice_start_brctr = in_kernel->entry_brctr;
    vmsplice_end_brctr = in_kernel->exit_brctr;

    /* Now print an annotated execution trace for the period of execution
       at which the kernel jumps back to the user space. 

       The annotated trace will look like this (the idea here is that a user 
       needs to understand at which point pages array gets allocated: 

       Call stack: 
 
          asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags) 
          |
          |--- static long do_vmsplice(struct file *file, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags)
               |
               |--- static ssize_t splice_to_pipe(struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)
                    |
                    |--- void put_page(struct page *page)
                         |
                         |--- static void put_compound_page(struct page *page)

       Full trace (all taken branches are included)

          asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags) 
          |  |
          |  fs/splice.c:sys_vmsplice:1268 to fs/splice.c:sys_vmsplice:1269
          |  |  
          |- static long do_vmsplice(struct file *file, const struct iovec __user *iov, unsigned long nr_segs, unsigned int flags)
               |    |
               |    fs/splice.c:do_vmsplice:1251 to fs/splice.c:get_iovec_page_array:1100
               |    fs/splice.c:get_iovec_page_array:1162 to mm/memory.c:get_user_pages:979
                    ....
               |    |
               |--- static ssize_t splice_to_pipe(struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)
                    |
                    |--- void put_page(struct page *page)
                         |
                         |--- static void put_compound_page(struct page *page)

 
     */
    xentt_bts_trace_annotate(bts_trace_analysis_in_out->trace, 
                                 vmsplice_start_brctr, 
                                 vmsplice_end_brctr);

    
    /* Next step: trace when the pages array gets overwritten 
       
       Note: the var_access_analysis understand from the syntax 
       ("do_vmsplice.pages") that "pages" is a local variable inside the 
       function "do_vm_splice"

       XXX: oh man array elements (e.g. pages[0])... what shell we do about them? 
     */ 
    var_access_analysis_in_out->var_list = {{"pages", W_ONLY}};
    var_access_analysis_in_out->var_list_size = 1;
    var_access_analysis_in_out->scope = "do_vmsplice";
    var_access_analysis_in_out->start_brctr = in_kernel->entry_brctr;
    var_access_analysis_in_out->end_brctr = k2u_jump_brctr;

    ret = xentt_run_replay(var_access_analysis_in_out, replay_session);
    if (ret) {
        ERR("Failed to run process trace analysis, ret:%d\n", ret); 
        return ret;
    }          

    /* Run a loop over a list of all accesses to page variable to see when it *
     * gets  overwritten. We fail if the variable is created with the rouge 
     * value and never gets overwritten.
     */

    found_overwrite = 0;
    initialized_as_rogue_value = 0;

    pages_access_list = xentt_var_access_get_access_list(var_access_analysis_in_out, "pages");
    pages_access = list_head(pages_access_list);
    if (xentt_val_to_ulong(pages_access->value) == rogue_page_address) {
        initialized_as_rogue_value = 1;
    }
    
    while((pages_access = list_next(pages_access)) != NULL) {

        if (xentt_val_to_ulong(pages_access->value) == rogue_page_address) {
            found_overwrite = 1; 
            break;
        }

        initialized_as_rogue_value = 0;
        pages_access = list_next(pages_access);       
        
    } 
    
    if(!found_overwrite && !initialized_as_rogue_value) {
        ERR("Fail to find a place at which page array gets overwritten\n");
        return -1;
    }

    if(initialized_as_rogue_value) {
        ERR("Page array is initialized as rogue value, analysis is done, check your code\n");
        return -1;
    }

    /* 
     * Next step: print out the code at which pages array gets overwritten 
     *
     * The output of this step is something like: 
     *
     *    fs/splice.c:get_iovec_page_array:1175
     *
     * 		for (i = 0; i < error; i++) {
     *                  const int plen = min_t(size_t, len, PAGE_SIZE - off);
     *
     *                  partial[buffers].offset = off;
     *                  partial[buffers].len = plen;
     *
     *                  off = 0;
     *                  len -= plen;
     *                  buffers++;
     *          }   
     */
    xentt_bts_trace_resolve_source(target, pages_access->eip);    

     /* 
      * Next step: dump the values of local variables when the page 
      * overwrite happens
      *
      */

    var_access_analysis_in_out->start_brctr = var_access->eip;
    var_access_analysis_in_out->end_brctr = var_access->eip;
    var_access_analysis_in_out->var_list = {"off", "plen", "buffers", "error"};
    var_access_analysis_in_out->var_list_size = 4;
    var_access_analysis_in_out->scope = "get_iovec_page_array";


    ret = xentt_run_replay(local_values_in_out, replay_session);
    if (ret) {
        ERR("Failed to run local values analysis, ret:%d\n", ret);
        return ret;
    } 

    printf("Local values at the moment when page array overflow occurs\n");
    for (int i = 0; i < var_access_analysis_in_out->var_list_size; i++) {
        printf("%s:%s\n", var_access_analysis_in_out->var_list[i], 
                          xentt_val_to_ulong(
                              list_head(xentt_var_access_get_access_list(
                                             var_access_analysis_in_out->var_list[i]))->val));
    }
 
    /* save the actual value of the get_iovec_page_array.buffers */
    buffer_val = xentt_val_to_ulong(list_head(xentt_var_access_get_access_list("buffers"))->val);
    error_val = xentt_val_to_ulong(list_head(xentt_var_access_get_access_list("error"))->val)

    /* Verify that it's actually an overflow */
    partial_size = xentt_resolve_var_size(target, "do_vmsplice.partial");
    partial_page_struct_size = xentt_resolve_var_size(target, "struct partial_page");

    if (partial_var_size >= partial_page_struct_size * buffer_val) {
        ERR("Fail to find overflow, fail\n");
        return -1;
    };

    printf("Local variable do_vmsplice.partial has size %lu, but is accessed at %lu\n",
           partial_var_size, partial_page_struct_size * buffer_val);
   
    printf("It is likely that array index variable ""error"" is too big, "
           "error:%lu\n", error_val);
    
    /* 
     * Next step: overflow analysis 
     * 
     * Overflow analysis is a little bit tricky/questionable. Our line of
     * attack is to see how variables ("len", "i", "start", and "vma->vm_end", 
     * which control execution of the loop, which defines the value of the 
     * "error" variable. 
     *
     * So what we think is helpful is an intersection of the powertrace 
     * with the value access analyses inside a specific function (get_user_pages). 
     * 
     * The output of this analysis will look like: 
     *  
     *  mm/memory.c:get_user_pages:(entry):976  (len = 0, i = 0)
     *  mm/memory.c:get_user_pages:1029 (i <- 1)
     *  mm/memory.c:get_user_pages:1031 (len <- 4294967295)
     *  from mm/memory.c:get_user_pages:1033 to mm/memory.c:get_user_pages:991
     *  mm/memory.c:get_user_pages:1029 (i <- 2)
     *  mm/memory.c:get_user_pages:1031 (len <- 4294967294)
     *  from mm/memory.c:get_user_pages:1033 to mm/memory.c:get_user_pages:991
     *  mm/memory.c:get_user_pages:1029 (i <- 3)
     *  mm/memory.c:get_user_pages:1031 (len <- 4294967293)
     *  from mm/memory.c:get_user_pages:1033 to mm/memory.c:get_user_pages:991
     *   ...
     *  mm/memory.c:get_user_pages:1029 (i <- 49)
     *  mm/memory.c:get_user_pages:1031 (len <- 4294967244)
     *  from mm/memory.c:get_user_pages:1033 to mm/memory.c:get_user_pages:1036
     *  mm/memory.c:get_user_pages:(entry):976 (len = 4294967244, i = 49)
     *
     *  To collect this trace we use the BTS trace analysis paired with a version
     *  of the variable access analysis.
     *
     * 
     * Later the trace is annotated. 
     */
   
    bts_trace_analysis_in_out->scope = PROCESS_SCOPE;
    bts_trace_analysis_in_out->pid = proc_lifetime_in_out->pid;;
    bts_trace_analysis_in_out->start_brctr = vmsplice_start_brctr;
    bts_trace_analysis_in_out->end_brctr = vmsplice_end_brctr;
 
    var_access_analysis_in_out->scope = "get_user_pages";
    var_access_analysis_in_out->var_list = {{"len", W_ONLY},
                                            {"i", W_ONLY},
                                            {"start", W_ONLY}};    


    /* pairing function which registers var_access_scope_analysis, when 
       bts_trace_analysis starts */
    bts_trace_analysis_in_out->on_start = register_var_access_analysis; 

    ret = xentt_run_replay(bts_trace_analysis_in_out, replay_session);
    if (ret) {
        ERR("Failed to run process trace analysis, ret:%d\n", ret); 
        return ret;
    }
   
    /* on every access to one of the tracked variables guest will exit to VMI, 
       thus the BTS will collect a trace which can be joined with the variable 
       access trace */
    xentt_trace_join_and_annotate(bts_trace_analysis_in_out, 
                                  var_access_scope_analysis_in_out);

   
    /*
     * Next step: see how "npages" becomes zero 
     *
     * We run the same variable access analysis to detect when "npages" 
     * becomes 0
     */
    bts_trace_analysis_in_out->scope = PROCESS_SCOPE;
    bts_trace_analysis_in_out->pid = proc_lifetime_in_out->pid;;
    bts_trace_analysis_in_out->start_brctr = vmsplice_start_brctr;
    bts_trace_analysis_in_out->end_brctr = vmsplice_end_brctr;
 
    var_access_scope_analysis_in_out->scope = "get_iovec_page_array";
    var_access_scope_analysis_in_out->var_list = {{"npages", W_ONLY},
                                                  {"off", W_ONLY},
                                                  {"len", W_ONLY}};    

    /* Again the pairing function */
    bts_trace_analysis_in_out->on_start = register_var_access_analysis; 

    ret = xentt_run_replay(bts_trace_analysis_in_out, replay_session);
    if (ret) {
        ERR("Failed to run process trace analysis, ret:%d\n", ret); 
        return ret;
    }
   
    /* And again annotate a join trace to show a human what is going on */
    xentt_trace_join_and_annotate(bts_trace_analysis_in_out, 
                                  var_access_scope_analysis_in_out);

 
    /* Since we've asked var_access_scope_analysis to track 3 variables, we 
       want to retrieve the list of accesses to "npages" */
    npages_access_list = xentt_var_access_get_list(var_access_scope_analysis_in_out, "npages");

    /* Now run a loop to detect at which branch counter npages is set to 0 
       We optimistically look for the last access */
    npages_access = list_head(npages_access_list);  
    while((npages_access = list_next(npages_access)) != NULL) {

        if (npages_access->value == 0) {
            last_zero_access = npages_access;             
        }

        npages_access = list_next(npages_access);       
        
    } 
   
    /*
     * Final step: see the instruction level trace of how integer overflow 
     * occurs
     *
     * Here we want to see an instruction level trace of how an integer overflow 
     * occurs. The main idea is that we annotate an instruction trace with the 
     * register values, bindings of registers to memory (as I understand it's possible 
     * through the symbol information), and show both source code and assembly. 
     *
     * The output of this analysis will look like this:
     *
     * 1158                     npages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
     * 1159                     if (npages > PIPE_BUFFERS - buffers)
     * 1160                               npages = PIPE_BUFFERS - buffers; 
     *  
     * 0xc018381f <sys_vmsplice+303>:	mov    $0x10,%eax	            -> {eax = 0 -> 0x10}
     * 0xc0183824 <sys_vmsplice+308>:	mov    0xffffff10(%ebp),%edi        -> {0xffffff10(ebp) (buffers) = 0, edi = 0 -> 0} 
     * 0xc018382a <sys_vmsplice+314>:	sub    0xffffff10(%ebp),%eax        -> {0xffffff10(ebp) (buffers) = 0, eax = 0x10 -> 0x10}
     * 0xc0183830 <sys_vmsplice+320>:	lea    0xfff(%esi,%ebx,1),%edx      -> {esi (off) = 0, ebx (len) = 0xffffffff, edx = 0 - > 0xffe}
     * 0xc0183837 <sys_vmsplice+327>:	shr    $0xc,%edx                    -> {edx = 0xffe -> 0} 
     * 0xc018383a <sys_vmsplice+330>:	cmp    %eax,%edx                    -> {eax = 0x10, edx = 0, eflags = ...}
     * 0xc018383c <sys_vmsplice+332>:	cmovbe %edx,%eax                    -> {edx = 0, eax (npages) = 0x10 -> 0x0} 
     * 0xc018383f <sys_vmsplice+335>:	mov    %eax,0xffffff0c(%ebp)        -> {eax (npages) = 0, 0xffffff0c(%ebp) (npages) = 0 -> 0}
     * 
     * 1162                     error = get_user_pages(current, current->mm,
     * 1163                                            (unsigned long) base, npages, 0, 0,
     * 1164                                            &pages[buffers], NULL);
     *
     * 0xc0183845 <sys_vmsplice+341>:	mov    %esp,%eax
     * 0xc0183847 <sys_vmsplice+343>:	and    $0xffffe000,%eax
     * 0xc018384c <sys_vmsplice+348>:	mov    (%eax),%edx
     * 0xc018384e <sys_vmsplice+350>:	lea    0xffffff9c(%ebp,%edi,4),%eax
     * 0xc0183852 <sys_vmsplice+354>:	mov    %eax,0x18(%esp)
     * 0xc0183856 <sys_vmsplice+358>:	mov    0xffffff0c(%ebp),%eax
     * 0xc018385c <sys_vmsplice+364>:	movl   $0x0,0x1c(%esp)
     * 0xc0183864 <sys_vmsplice+372>:	movl   $0x0,0x14(%esp)
     * 0xc018386c <sys_vmsplice+380>:	movl   $0x0,0x10(%esp)
     * 0xc0183874 <sys_vmsplice+388>:	mov    %eax,0xc(%esp)
     * 0xc0183878 <sys_vmsplice+392>:	mov    %ecx,0x8(%esp)
     * 0xc018387c <sys_vmsplice+396>:	mov    0x84(%edx),%eax
     * 0xc0183882 <sys_vmsplice+402>:	mov    %edx,(%esp)
     * 0xc0183885 <sys_vmsplice+405>:	mov    %eax,0x4(%esp)
     * 0xc0183889 <sys_vmsplice+409>:	call   0xc0149420 <get_user_pages>
     *
     */
    single_step_analysis_in_out->start_brctr = last_zero_access->brctr - 10;
    single_step_analysis_in_out->end_brctr = last_zero_access->brctr + 10;
 
    ret = xentt_run_replay(single_step_trace_analysis_in_out, replay_session);
    if (ret) {
        ERR("Failed to run process trace analysis, ret:%d\n", ret); 
        return ret;
    }

    xentt_single_step_annotate_trace(single_step_analysis_in_out);       
 
    return 0;
}
