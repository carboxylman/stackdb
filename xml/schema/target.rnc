#
# Copyright (c) 2011, 2012, 2013 The University of Utah
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#

default namespace vmi1 = "http://anathema.flux.utah.edu/schema/vmi/1"

include "common.rnc"

TargetTypeT = "none" | "ptrace" | "xen"
TargetModeT = "none" | "live" | "replay" | "record"
ThreadBPModeT = "strict" | "semiStrict" | "loose"

TargetSpecT = 
    attribute type { TargetTypeT },

    element mode { TargetModeT },
    element threadBPMode { ThreadBPModeT },
    element startPaused { xsd:boolean },
    element dedicatedMonitor { xsd:boolean }?,
    element stdinBytes { xsd:hexBinary }?,
    element logStdout { xsd:boolean }?,
    element logStderr { xsd:boolean }?,

    element backendSpec {
        (TargetXenSpec | TargetPtraceSpec)
    }

TargetSpec = element targetSpec { TargetSpecT }

TargetXenSpecT = 
    (element domain { text }
    | (element configFile { text },
       element replayLogFile { text }?))

TargetXenSpec = element targetXenSpec { TargetXenSpecT }

TargetPtraceSpecT = 
    (element pid { xsd:int }
    | (element program { text },
       element arguments {
           element argument { xsd:string }*
       },
       element environment {
           element envvar { xsd:string }*
       }))

TargetPtraceSpec = element targetPtraceSpec { TargetPtraceSpecT }

ThreadStatusT = 
    "unknown" | "running" | "stopped" | "sleeping" | "zombie" | "dead" 
    | "blockedio" | "paging" | "paused"
ThreadStatus = element threadStatus { ThreadStatusT }

ThreadT = 
    element thid { ThreadIdT },
    element tid { TargetIdT },
    ThreadStatus
Thread = element thread { ThreadT }

TargetStatusT = 
    "unknown" | "running" | "paused" | "dead" | "stopped" | "error" | "done"
TargetStatus = element targetStatus { TargetStatusT }

TargetT = 
    attribute name { text },
    element tid { TargetIdT },
    TargetSpec,
    TargetStatus,
    Thread*,
    AddrSpace*
Target = element target { TargetT }

AddrSpaceT = 
    attribute name { text },
    attribute id { xsd:int },
    element tid { TargetIdT },
    MemRegion+
AddrSpace = element addrSpace { AddrSpaceT }

MemRegionTypeT = 
    "unknown" | "heap" | "stack" | "vdso" | "vsyscall" | "anon" | "main" | "lib"
MemRegionType = element memRegionType { MemRegionTypeT }

MemRegionT = 
    attribute name { text },
    element baseLoadAddr { ADDR },
    element basePhysAddr { ADDR },
    element baseVirtAddr { ADDR },
    element physOffset   { OFFSET },
    MemRegionType,
    MemRange+,
    element debugFileId { DebugFileIdT }+
MemRegion = element memRegion { MemRegionT }

MemRangeT =
    attribute read { xsd:boolean },
    attribute write { xsd:boolean },
    attribute execute { xsd:boolean },
    element start { ADDR },
    element end { ADDR },
    element offset { ADDR }
MemRange = element memRange { MemRangeT }

##
## Probe stuff.
##
ProbeIdT = xsd:int
ProbepointTypeT = "break" | "watch"
ProbepointType = element probepointType { ProbepointTypeT }

ProbepointStyleT = "fastest" | "hw" | "sw"
ProbepointStyle = element probepointStyle { ProbepointStyleT }

ProbepointWhenceT = "auto" | "exec" | "write" | "readwrite"
ProbepointWhence = element probepointWhence { ProbepointWhenceT }

ProbepointSizeT = "auto" | "0" | "2" | "4" | "8"
ProbepointSize = element probepointSize { ProbepointSizeT }

ProbeT = 
    element pid { ProbeIdT },
    element name { xsd:string },
    element addr { ADDR },
    element type { ProbepointTypeT },
    element style { ProbepointTypeT },
    element whence { ProbepointWhenceT },
    element psize { ProbepointSizeT },

    element tid { TargetIdT },
    element thid { ThreadIdT }
Probe = element probe { ProbeT }

RegisterValueT = 
    element name { xsd:token },
    element value { xsd:unsignedLong }
RegisterValue = element registerValue { RegisterValueT }

ProbeEventT = 
    element probeEventType { "pre" | "post" },
    element probe { ProbeT },
    element thread { ThreadT },
    element registerValues {
        element registerValue { RegisterValueT }*
    }
ProbeEvent = element probeEvent { ProbeEventT }

##
## Action stuff (including single step stuff).
##
ActionIdT = xsd:int
ActionTypeT = "return" | "regmod" | "memmod" | "singlestep"
ActionType = element actionType { ActionTypeT }
HandlerMsgT = "success" | "failure" | "stepping" | "stepping_at_bp"
HandlerMsg = element handlerMsg { HandlerMsgT }
ActionWhenceT = "oneshot" | "repeatpre" | "repeatpost"
ActionWhence = element actionWhence { ActionWhenceT }

ActionSpecT = 
    element tid { TargetIdT },
    element pid { ProbeIdT },
    element type { ActionTypeT },
    element whence { ActionWhenceT },
    (element return { element code { xsd:unsignedLong } }
     | element regmod { RegisterValue }
     | element memmod { element addr { ADDR },
       	       	      	element data { xsd:hexBinary } }
     | element singlestep { element stepCount { xsd:int } })
ActionSpec = element actionSpec { ActionSpecT }
ActionSpecsT = ActionSpec*
ActionSpecs = element actionSpecs { ActionSpecsT }

ActionT = 
    element aid { ActionIdT },
    ActionSpec
Action = element action { ActionT }

ActionEventT = 
    HandlerMsg,
    element actionDetail { element stepCount { xsd:int }? },
    element action { ActionT },
    element thread { ThreadT },
    element registerValues {
        element registerValue { RegisterValueT }*
    }
ActionEvent = element actionEvent { ActionEventT }    
