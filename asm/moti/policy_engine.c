/*
 * Copyright (c) 2011, 2012, 2013, 2014 The University of Utah
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*  Policy_engine outline: 
 *   Step1: Initialize  the CLIPS environment.
 *   Step2: Load the rules file into the framework: both application levl rules
 *	    and recovery rules
 *   Step3: Repeat the following steps at periodic intrrvals.
 *	Step3.1: Makes a call to the VMI based tools to gather system snapshot: base facts
 *	Step3.2: Loads the facts file generated by VMI into the clips framework
 *	Step3.3: The application level rules activated generate a set of anomaly facts.
 *	Step3.4: The anomaly facts active a bunch of recvery facts.
 *	Step3.5: The activated recovery facts generate a set of recovery facts which 
 *		 trigger the recovery action.
 *  
 *  Input:
 *	1. Loop repeat interval
 *	2. The .clp file which encodes application level knowledge
 *	3. The .clp file which encodes the recovey rules
 *  
 *  Output:
 *	1. A fact file which represent the state of the Virtual appliance
 *
 * Dependencies and Interactions
 *	1. Capability to interact with VMI tools to gather base facts
 *	2. Capability to interact with the the command_interface to drive 
 *	   recovery actions
 */


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/time.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <inttypes.h>
#include <signal.h>
#include <argp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include "log.h"
#include "dwdebug.h"
#include "target_api.h"
#include "target.h"
#include "target_xen_vm.h"
#include "probe_api.h"
#include "probe.h"
#include "alist.h"
#include "list.h"
#ifdef ENABLE_A3
#include "a3lib.h"
#endif
#include "policy_engine.h"
#include "repair_engine.h"
#include "clips.h"

struct target *target = NULL;
char base_fact_file[100];
unsigned long *sys_call_table = NULL;
char **sys_call_names = NULL;
unsigned long **function_prologue = NULL;
unsigned char *res = NULL;
ADDR syscall_table_vm;


int save_sys_call_table_entries() {

    int i, max_num;
    struct target_os_syscall *sc;
    unsigned char  prologue[16];
    struct bsymbol *bs;
    struct value *v;
    struct target_location_ctxt *tlctxt;
    
    if (opts.dump_debug)
	fprintf(stdout,"INFO: Saving the state of the initial system call table.\n");
    /* Load the syscall table */
    bs = target_lookup_sym(target,"sys_call_table",NULL,NULL,
				    SYMBOL_TYPE_FLAG_VAR);
    if (!bs) {
	fprintf(stdout, "ERROR: Could not lookup symbol sys_call_table!\n");
	exit(0);
    }	

    tlctxt = target_location_ctxt_create_from_bsymbol(target, TID_GLOBAL,bs);

    v = target_load_symbol(target,tlctxt,bs,LOAD_FLAG_NONE);
    if (!v) {
	fprintf(stdout,"ERROR: Could not load sys_call_table!\n");
	bsymbol_release(bs);
	bs = NULL;
	exit(0);
    }
    syscall_table_vm = value_addr(v);
    if (opts.dump_debug)
	fprintf(stdout,"INFO: Symbol syscall_table is at address %lx\n",
							syscall_table_vm);
    value_free(v);
    bsymbol_release(bs);
    bs = NULL;

    if (opts.dump_debug)
	fprintf(stdout,"INFO: Loading the syscall table.\n");
    if(target_os_syscall_table_load(target)) {
	fprintf(stdout,"ERROR: Failed to load the syscall table.\n");
	return 1;
    }

    max_num = target_os_syscall_table_get_max_num(target);
    if(max_num < 0) {
	fprintf(stdout,"ERROR: Failed to get the max number of target sysscalls.\n");
	return 1;
    }
    if (opts.dump_debug)
	fprintf(stdout,"INFO: maximum number of system calls %d \n",max_num);

    /* Allocate memory for the sys_call_table and sys_call_names */
    sys_call_table  = (unsigned long *) malloc(max_num * sizeof(unsigned long));
    if(sys_call_table == NULL) {
	fprintf(stdout,"ERROR: Failed to allocate memory for sys_call_table.\n");
	exit(0);
    }
    sys_call_names = (char **) malloc(max_num * sizeof(char *));
    if(sys_call_names == NULL) {
	fprintf(stdout,"ERROR: Failed to allocate memmory for sys_call_names.\n");
	exit(0);
    }
    
    function_prologue = (unsigned long **) malloc(max_num * sizeof(unsigned long *));
    if(function_prologue == NULL) {
	fprintf(stdout,"ERROR: Failed to allocate memory for function prologue.\n");
	exit(0);
    }

    for(i = 0; i < max_num; i++) {
	sc = target_os_syscall_lookup_num(target, i);
	if(!sc) {
	    continue;
	}
	if(sc->bsymbol) {
	    
	    if (opts.dump_debug)
		fprintf(stdout,"%d\t %"PRIxADDR"\t%s\n", sc->num, sc->addr, 
					    bsymbol_get_name(sc->bsymbol));
	    sys_call_table[sc->num] = sc->addr;
	    sys_call_names[sc->num] =  (char *) malloc(100* sizeof(char));
	    if(sys_call_names[sc->num] == NULL) {
		fprintf(stdout,"ERROR: Failed to allocate memory for the string.\n");
		exit(0);
	    }
	    strcpy(sys_call_names[sc->num], bsymbol_get_name(sc->bsymbol));
	    function_prologue[sc->num] = (unsigned long *) malloc(2 * sizeof(unsigned long));

	    res = target_read_addr(target, sc->addr, 16, prologue);
	    if(!res) {
		fprintf(stdout, "ERROR: Could not read 8 bytes at 0x%"PRIxADDR"!\n",sc->addr);
		exit(0);
	    }
	    memcpy(function_prologue[sc->num], &prologue,16);
	    
	}
    }
    return 0;
}

target_status_t cleanup() {

    target_status_t retval;
    target_pause(target);
    retval = target_close(target);
    target_free(target);
    return retval;
}

int generate_timestamp(char *date) {

    time_t t;
    struct tm *tm;
    int result = 0;

    time(&t);
    tm = localtime(&t);
    result = strftime(date,100, "state_information/%Y_%m_%d_%H_%M_%S.fac", tm);

    return result;
}

int generate_snapshot() {

    int result = 0;
    target_status_t status;
    static struct timeval tm1;
    static struct timeval tm2;
    unsigned long long t;

    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);

    /* Pause the target */
    if ((status = target_status(target)) != TSTATUS_PAUSED) {	
	if (target_pause(target)) {
		fprintf(stderr,"Failed to pause the target \n");
		result = 1;
		goto resume;
	 }
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to pause the target is %llu ms\n", t); 
    }

    /* Start making calls to each of the VMI function */ 
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = process_info();
    if(result) {
	fprintf(stdout,"ERROR: process_info function failed\n");
	result = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to get process info is %llu ms\n", t); 
    }

    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result =  file_info();
    if(result) {
	fprintf(stdout,"ERROR: file_info function failed.\n");
	result = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to get file info is %llu ms\n", t);
    }

    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = module_info();
    if(result) {
	fprintf(stdout,"ERRROR: module_info function failed.\n");
	result = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stdout,"INFO: Time taken to get module info is %llu ms\n", t);
    }
    
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = cpu_load_info();
    if(result) {
	fprintf(stdout,"ERROR: cpu_load_info failed.\n");
	result = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stdout,"INFO: Time taken to get cpu load info is %llu ms\n", t);
    }

   /*
    result = process_cpu_utilization();
    if(result) {
	fprintf(stdout,"ERROR: process_cpu_utilization failed.\n");
	result = 1;
	goto resume;
    }
    */

    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = object_info();
    if(result) {
	fprintf(stdout,"ERROR: object_info failed.\n");
	result  = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stdout,"INFO: Time taken to get object file info is %llu ms\n", t);
    }
    
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = syscalltable_info();
    if(result) {
	fprintf(stdout,"ERROR: syscallcalltable_info failed.\n");
	result = 1;
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to get syscalltable info is %llu ms\n", t);
    }
   
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = commandline_info();
    if( result) {
	fprintf(stdout,"ERROR: commandline_info failed.\n");
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to get commandline info is %llu ms\n", t);
    }
    
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = syscall_hooking_info();
    if( result) {
	fprintf(stdout,"ERROR: syscall_hooking_info failed.\n");
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to check for hooked system calls is %llu ms\n", t);
    }
  
    /*
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    result = socket_info();
    if( result) {
	fprintf(stdout,"ERROR: socket_info failed.\n");
	goto resume;
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to gather information about open sockets is %llu ms\n", t);
    }
    */
resume:
    if (opts.dump_timing)
	gettimeofday(&tm1, NULL);
    if ((status = target_status(target)) == TSTATUS_PAUSED) {
	if (target_resume(target)) {
	    fprintf(stdout, "ERROR: Failed to resume target.\n ");
	    result = 1;
	}
    }
    if (opts.dump_timing) {
	gettimeofday(&tm2, NULL);
	timersub(&tm2, &tm1, &tm2);
	t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stderr,"INFO: Time taken to resume the target is %llu ms\n", t);
    }

    return result;
}


#define PE_ARGP_APP_FILE    0x474747
#define PE_ARGP_REC_FILE    0x474748
#define PE_ARGP_WAIT_TIME   0x474749
#define PE_ARGP_DUMP_TIMING 0x47474a
#define PE_ARGP_DUMP_DEBUG  0x47474b
#define PE_ARGP_DISABLE_RECOVERY 0x47474c
#define PE_ARGP_A3_SERVER   0x47474d

struct argp_option pe_argp_opts[] = {
    { "pe-app-knowledge-file",PE_ARGP_APP_FILE,"FILE",0,"The application knowledge CLIPS file; defaults to ./application_knowledge.cls.",0 },
    { "pe-recovery-rules-file",PE_ARGP_REC_FILE,"FILE",0,"The recovery rules CLIPS file; defaults to ./recovery_constructs.cls",0 },
    { "pe-interval",PE_ARGP_WAIT_TIME,"SECONDS",0,"The wait time in between policy engine checks of the domain; defaults to 120 seconds",0 },
    { "pe-dump-timing",PE_ARGP_DUMP_TIMING,NULL,0,"Dump timing info to stderr.",0 },
    { "pe-dump-debug",PE_ARGP_DUMP_DEBUG,NULL,0,"Dump debug info to stdout.",0},
    { "pe-disable-recovery",PE_ARGP_DISABLE_RECOVERY,NULL,0,"Disable the recovery component.",0},
#ifdef ENABLE_A3
    { "pe-a3-server",PE_ARGP_A3_SERVER,"IP:PORT",0,"Report A3 events to the indicated server",0},
#endif
        { 0,0,0,0,0,0 },
};



error_t pe_argp_parse_opt(int key,char *arg,struct argp_state *state) {
    struct pe_argp_state *opts = \
	(struct pe_argp_state *)target_argp_driver_state(state);
	    
    switch (key) {
    case ARGP_KEY_ARG:
	return ARGP_ERR_UNKNOWN;
    case ARGP_KEY_ARGS:
	/* Eat all the remaining args. */
	if (state->quoted > 0)
	    opts->argc = state->quoted - state->next;
	else
	    opts->argc = state->argc - state->next;
	if (opts->argc > 0) {
	    opts->argv = calloc(opts->argc,sizeof(char *));
	    memcpy(opts->argv,&state->argv[state->next],opts->argc*sizeof(char *));
	    state->next += opts->argc;
	}
	return 0;
    case ARGP_KEY_INIT:
	target_driver_argp_init_children(state);
	return 0;
    case ARGP_KEY_END:
    case ARGP_KEY_NO_ARGS:
    case ARGP_KEY_SUCCESS:
	opts->tspec = target_argp_target_spec(state);
	return 0;
    case ARGP_KEY_ERROR:
    case ARGP_KEY_FINI:
	return 0;

    case PE_ARGP_APP_FILE:
	opts->app_file_path = arg;
	break;
    case PE_ARGP_REC_FILE:
	opts->recovery_rules_file = arg;
	break;
    case PE_ARGP_WAIT_TIME:
	opts->wait_time = atoi(arg);
	break;
    case PE_ARGP_DUMP_TIMING:
	opts->dump_timing = 1;
	break;
    case PE_ARGP_DUMP_DEBUG:
	opts->dump_debug = 1;
	break;
    case PE_ARGP_DISABLE_RECOVERY:
	opts->disable_recovery = 1;
	break;
#ifdef ENABLE_A3
    case PE_ARGP_A3_SERVER:
	opts->a3_server = arg;
	break;
#endif

    default:
	return ARGP_ERR_UNKNOWN;
    }

    return 0;
}

struct argp pe_argp = {
        pe_argp_opts,pe_argp_parse_opt,NULL,NULL,NULL,NULL,NULL,
};

void sigh(int signo) {

    if (target) {
	target_pause(target);
	fprintf(stderr,"Ending monitoring on signal %d.\n",signo);
	cleanup();
	fprintf(stderr,"Ended monitoring.\n");
    }

    exit(0);
}

void dumpstat(char *msg, int full)
{
    static char *pfile;
    static int lsize, lrss, ldata, lstk;
    int size, rss, data, stk;
    FILE *fd;

    if (pfile == NULL) {
	lsize = lrss = ldata = lstk = -1;
	pfile = malloc(20);
	snprintf(pfile, 20, "/proc/%d/status", getpid());
    }
    fd = fopen(pfile, "r");
    if (fd != NULL) {
	char line[100];

	size = rss = data = stk = -1;
	fprintf(stderr, "%s:\n", msg);
	while (fgets(line, 100, fd) != NULL) {
	    if (strncmp(line, "VmSize", 6) == 0)
		sscanf(line, "VmSize: %d kB", &size);
	    else if (strncmp(line, "VmRSS", 5) == 0)
		sscanf(line, "VmRSS: %d kB", &rss);
	    else if (strncmp(line, "VmData", 6) == 0)
		sscanf(line, "VmData: %d kB", &data);
	    else if (strncmp(line, "VmStk", 5) == 0) {
		sscanf(line, "VmStk: %d kB", &stk);
		break;
	    }
	}
	if (full)
	    fprintf(stderr, "  size=%d, rss=%d, data=%d, stk=%d\n",
		    size, rss, data, stk);
	else
	    fprintf(stderr, "  Dsize=%d, Drss=%d, Ddata=%d, Dstk=%d\n",
		    (size-lsize), (rss-lrss), (data-ldata), (stk-lstk));
	lsize = size;
	lrss = rss;
	ldata = data;
	lstk = stk;
	fclose(fd);
    }
}

int main( int argc, char** argv) {

    int result = 0;
    char targetstr[80];
    struct target_spec *tspec = NULL;
    target_status_t tstat;
    int iteration = 1;
    struct stat st;
    FILE *fp;

    memset(&opts,0,sizeof(opts));
    opts.app_file_path = "application_knowledge.cls";
    opts.recovery_rules_file = "recovery_constructs.cls";
    opts.wait_time = 120;
    
    tspec = target_argp_driver_parse(&pe_argp,&opts,argc,argv,TARGET_TYPE_XEN,1);
    if (!tspec) {
	fprintf(stdout,"ERROR: Could not parse target arguments!\n");
	exit(-1);
    }

    signal(SIGHUP,sigh);
    signal(SIGINT,sigh);
    signal(SIGQUIT,sigh);
    signal(SIGABRT,sigh);
    signal(SIGSEGV,sigh);
    signal(SIGPIPE,sigh);
    signal(SIGALRM,sigh);
    signal(SIGTERM,sigh);
    signal(SIGUSR1,sigh);
    signal(SIGUSR2,sigh);

    dwdebug_init();
    target_init();
    atexit(target_fini);
    atexit(dwdebug_fini);

     target = target_instantiate(tspec,NULL);
     if (!target) {
	fprintf(stdout,"ERROR: Could not instantiate target!\n");
	exit(0);
     }
    if (target_open(target)) {
	fprintf(stdout,"ERROR: Could not open %s!\n",targetstr);
	exit(0);
    }

    if (opts.dump_debug)
	fprintf(stdout,"INFO: Initializing the CLIPS environment.\n");
    InitializeEnvironment();

#ifdef ENABLE_A3
    if (opts.a3_server != NULL) {
	fprintf(stdout,"INFO: Initializing the A3 environment.\n");

	/* XXX how do we extract the command line -m argument? */
	if (a3_hc_init("a3-ncz", opts.a3_server, 0)) {
	    fprintf(stdout,"ERROR: Could not initialize A3\n");
	    exit(0);
	}
    }
#endif

    /* Create a directory  with files required to keep track of state information. */
    if(stat("state_information", &st) == 1) {
	mkdir("state_information",0700);
    }
    
    if ((fp = fopen("state_information/cpu_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/module_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/process_priv_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/process_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/tcp_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/udp_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/unload_unknown_object_state_info.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
    if ((fp = fopen("state_information/recovery_action.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
#ifdef ENABLE_A3
    if ((fp = fopen("state_information/anomalies_detected.fac", "w")) != NULL)
	fclose(fp);
    else
	result++;
#endif
    if (result)
	fprintf(stdout, "WARNING: Could not truncate all files in state_information.\n");

    /* Copy the initil system_call_table contents */
    result = save_sys_call_table_entries();
    if(result) {
	fprintf(stdout,"ERROR: Failed to save the initial system call table entries.\n");
	exit(0);
    }
    
    while(1) {	
	static struct timeval tm1;
	static struct timeval tm2;

	fprintf(stdout,"============================ ITERATION %d ============================\n",iteration++);
        if (opts.dump_debug)
	    fprintf(stdout,"INFO: Loading the application level rules\n");
dumpstat("Before load", 1);
	result = Load(opts.app_file_path);
	if(result != 1) {
	    fprintf(stdout,"ERROR: Failed to load the application rules file\n");
	    exit(0);
	}	
dumpstat("After load", 0); 

	// Generate a time stamp for the base facts file name
	result = generate_timestamp(base_fact_file);
	if(!result) {
	    fprintf(stdout,"Failed to generate timestamp");
	    exit(0);
	}
	if (opts.dump_debug)
	    fprintf(stdout," INFO: Base fact file name  = %s\n",base_fact_file);

	/*  Make call to the base VMI  base function. This function invokes all
	    the VMI tools that gather state information of the virtual appliance 
	*/	
	gettimeofday(&tm1, NULL);
	result = generate_snapshot();
	gettimeofday(&tm2, NULL);
dumpstat("After snapshot", 0);
	if( result) {
	    fprintf(stdout,"ERROR: Failed to generate the system snapshot.\n \
		    Trying again...\n");
	    continue;
	}
	timersub(&tm2, &tm1, &tm2);
	unsigned long long t = (1000 * tm2.tv_sec + tm2.tv_usec / 1000);
	fprintf(stdout,"INFO: Time taken to generate the snapshot is %llu ms\n", t); 

	if (opts.dump_debug)
	    fprintf(stdout,"INFO: Resetting the CLIPS environemnt\n");
	Reset();
dumpstat("After Reset", 0);
	
	if (opts.dump_debug) {
	    result = Watch("all");
	    if(!result) {
		fprintf(stdout,"Error: Faild to watch \n");
	    }
	}
	
	if (opts.dump_debug)
	    fprintf(stdout,"INFO: Loading the base facts file\n");
	result = LoadFacts(base_fact_file);
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the base facts file '%s'.\n", base_fact_file);
	   exit(0);
	}
	
	/* Load previous cpu utilization state */
	result = LoadFacts("state_information/cpu_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the tcp_state_info file.\n");
	   exit(0);
	}
dumpstat("After LoadFacts", 0);

	if (opts.dump_debug)
	    fprintf(stdout,"INFO: Parsing the base facts through the application rules\n");
	result = Run(-1L);
dumpstat("After Run", 0);
	if (opts.dump_debug)
	    fprintf(stdout,"INFO : %d application rules were fired\n",result);
	/* At this time the anomaly facts are generated. Now load the
	 * state information from the previos iteration.
	 */
	
#ifdef ENABLE_A3
	if(opts.a3_server)
	    report_anomalies();
#endif

	if (opts.dump_debug)
	    fprintf(stdout,"INFO: Loading the state information of recovery facts from the previous execution \n");
dumpstat("Before LoadFacts2", 0);
	result = LoadFacts("state_information/process_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the process_state_info file.\n");
	   exit(0);
	}
	
	result = LoadFacts("state_information/module_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the module_state_info file.\n");
	   exit(0);
	}

	result = LoadFacts("state_information/udp_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the base udp_state_info file.\n");
	   exit(0);
	}
	
	result = LoadFacts("state_information/tcp_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the tcp_state_info file.\n");
	   exit(0);
	}

	result = LoadFacts("state_information/process_priv_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the process_priv_info file.\n");
	   exit(0);
	}

	result = LoadFacts("state_information/unload_unknown_object_state_info.fac");
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the unload_unknown_object_info file.\n");
	   exit(0);
	}
dumpstat("After LoadFacts2", 0);

	if (opts.dump_debug)	
	    fprintf(stdout,"INFO: Loading the  recovery rules file\n");
	result = Load(opts.recovery_rules_file);
	if(!result) {
	   fprintf(stdout,"ERROR: Failed to load the recovery facts file '%s'.\n",
		   opts.recovery_rules_file);
	   exit(0);
	}
dumpstat("After Load", 0);

	result = Run(-1L);
dumpstat("After Run2", 0);
	if (opts.dump_debug)
	    fprintf(stdout,"INFO : %d recovery rules were fired\n",result);

	if(!opts.disable_recovery) {
	    if (opts.dump_debug)
		fprintf(stdout,"INFO: Parsing the recovery action file.\n");
	    result = parse_recovery_action();
dumpstat("After parse_recovery_action", 0);
	    if(result) {
		fprintf(stdout,"ERROR: parse_recovery_action function call failed.\n");
		exit(0);
	    }
	}
	
	if (opts.dump_debug)
	    fprintf(stdout,"INFO: Clearing up all the facts and rules\n");
	Clear();
dumpstat("After Clear", 0);
	fprintf(stdout," Sleeping for %d seconds before the next iteration.\n", opts.wait_time);
	sleep(opts.wait_time);
    }

    fflush(stderr);
    fflush(stdout);
    tstat = cleanup();
    if(tstat == TSTATUS_DONE) {
	printf(" Monitoring finished.\n");
	return 0;
    }
    else if (tstat == TSTATUS_ERROR) {
	printf("Monitoring failed!\n");
	return 1;
    }
    else {
	printf("Monitoring failed with %d!\n",tstat);
	return 1;
    }
    return 0;
}
