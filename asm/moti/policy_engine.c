/*  Policy_engine outline: 
 *   Step1: Initialize  the CLIPS environment.
 *   Step2: Load the rules file into the framework: both application levl rules
 *	    and recovery rules
 *   Step3: Repeat the following steps at periodic intrrvals.
 *	Step3.1: Makes a call to the VMI based tools to gather system snapshot: base facts
 *	Step3.2: Loads the facts file generated by VMI into the clips framework
 *	Step3.3: The application level rules activated generate a set of anomaly facts.
 *	Step3.4: The anomaly facts active a bunch of recvery facts.
 *	Step3.5: The activated recovery facts generate a set of recovery facts which 
 *		 trigger the recovery action.
 *  
 *  Input:
 *	1. Loop repeat interval
 *	2. The .clp file which encodes application level knowledge
 *	3. The .clp file which encodes the recovey rules
 *  
 *  Output:
 *	1. A fact file which represent the state of the Virtual appliance
 *
 * Dependencies and Interactions
 *	1. Capability to interact with VMI tools to gather base facts
 *	2. Capability to interact with the the command_interface to drive 
 *	   recovery actions
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "clipssrc/clips.h"


char generate_timestamp(char *date) {

    time_t t= time(0);
    struct tm *tm;
    tm = gmtime(&t);
    int result = 0
    result = strftime(date,sizeof(date), "%Y%m%d%H%M%S", tm);
    
    return result;
}


int main( int argc, char** argv) {

    int wait_time = 0;
    char *app_file_path = NULL;
    char base_fact_file[10];
    char recovery_fact_file[100;
    int result = 0;


    // Check if file name and the wait_time have been passed as arguments
    if( argc != 3) {
	fprintf(stdout,
		"ERROR: Two arguments need\n 1. File path \n 2. Wait time\n");
	exit(0);
    }
    app_file_path = argv[0];
    wait_time = atoi(argv[1]);

    // Initialize the CLIPS environment
    InitializeEnvironment();
    fprintf(stdout,"INFO: Loading the application level rules\n");
    Load(app_file_path);
    if(result != 1) {
	fprintf(stdout,"ERROR: Failed to load the application rules file\n");
	exit(0);
    }
    fprintf(stdout,"INFO: Loading the recovery rules.\n");
    result = Load("recovery_rules.clp");
    if(result != 1) {
	fprintf(stdout," ERROR: Failed to load the recovery rules file\n");
	exit(0);
    }

    // Start an infinite loop to periodically execute steps 31. to 3.5 
    while(1) {

	// Generate a time stamp for the base facts file name
	result = generate_timestamp(base_fact_file);
	if!(result) {
	    fprintf(stdout,"Failed to generate timestamp");
	    exit(0);
	}

	// Make call to the base VMI  base function. This function invokes all the 
	// VMI tools that gather state information of the virtual appliance/
	
	result = generate_snapshot(base_fact_file);
	if( result) {
	    fprintf(stdout,"ERROR: Failed to generate the system snapshot.\n
		     Trying again...\n");
	    continue;
	}

	fprintf(stdout"INFO: Loading the base facts file\n");
	result = LoadFacts(date);
	if(!result) {
	    fprintf(stdout,"ERROR: Failed to load the base factsf file.\n");
	    exit(0);
	}
	fprintf(stdout,"INFO: Resetting the CLIPS environemnt\n");
	Reset();
	fprintf(stdout,"INFO: Parsing the base facts through the application rules\n");
	result = Run(-1L);
	fprintf(stdout,"INFO : %d application rules were fired\n",result);
	// At this time the anomaly facts are generated.
	// We have to run them through the recovery rules now.
	
	result = Run(-1L);
	fprintf(stdout,"INFO : %d recovery rules were fired\n",result);

	result = generate_timestamp(recovery_fact_file);
	if(!result){
	    fprintf(stdout,"ERROR: Failed to generate a timestamp\n");
	    exit(0);
	}
	result = SaveFacts(recovery_fact_file,  VISIBLE_SAVE, NULL);
	if(!result) {
	    fprintf(stdout,"ERROR: Failed to save the recovery facts\n");
	    exit(0);
	}
	// Now based on the recovery facts that are generated we trigger recovery actions.
	// how do we do this ?
	

	sleep(wait_time);
    }

}



